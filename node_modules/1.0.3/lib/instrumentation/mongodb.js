
'use strict'

var ParsedStatement = require('../db/parsed-statement')
var shimmer = require('../shimmer')
var logger = require('../logger').child({ component: 'mongodb' })
var MONGODB = require('../metrics/names').MONGODB
//var IOData = require('../metrics/iodata')

// legacy endpoint enumerations
var DB_OPS = [
  'addUser',
  'authenticate',
  'collection',
  'collectionNames',
  'collections',
  'command',
  'createCollection',
  'createIndex',
  'cursorInfo',
  'dereference',
  'dropCollection',
  'dropDatabase',
  'dropIndex',
  'ensureIndex',
  'eval',
  'executeDbAdminCommand',
  'indexInformation',
  'logout',
  'open',
  'reIndex',
  'removeUser',
  'renameCollection',
  'stats',
  '_executeInsertCommand',
  '_executeQueryCommand'
]

var COLLECTION_OPS = [
  'aggregate',
  'bulkWrite',
  'count',
  'createIndex',
  'deleteMany',
  'deleteOne',
  'distinct',
  'drop',
  'dropAllIndexes',
  'dropIndex',
  'ensureIndex',
  'findAndModify',
  'findAndRemove',
  'findOne',
  'findOneAndDelete',
  'findOneAndReplace',
  'findOneAndUpdate',
  'geoHaystackSearch',
  'geoNear',
  'group',
  'indexes',
  'indexExists',
  'indexInformation',
  'insert',
  'insertMany',
  'insertOne',
  'isCapped',
  'mapReduce',
  'options',
  'parallelCollectionScan',
  'reIndex',
  'remove',
  'rename',
  'replaceOne',
  'save',
  'stats',
  'update',
  'updateMany',
  'updateOne',
  'findByIdAndRemove',
  'find',
  'findByIdAndUpdate',
  'findById'
]

var GRID_OPS = [
  'put',
  'get',
  'delete'
]

var CURSOR_OPS = [
  'nextObject',
  'next',
  'toArray',
  'count',
  'explain'
]

module.exports = initialize

function initialize(agent, mongodb) {
    if (!mongodb) return
    var tracer = agent.tracer
    var moduleNameToWrapFunction = {
        'GridStore': wrapGrid,
        'OrderedBulkOperation': wrapQuery,
        'UnorderedBulkOperation': wrapQuery,
        'CommandCursor': wrapQuery,
        'AggregationCursor': wrapQuery,
        'Cursor': wrapQuery,
        'Collection': wrapQuery,
        'Db': wrapDb
    }

    function instrumentModules(err, instrumentations) {
        if (err) {
            logger.trace('Unable to instrument mongo using the apm api due to error: %s', err)
            // fallback to legacy instrumentation?
            return
        }
        instrumentations.forEach(instrumentModule)
    }

    function applyInstrumentation(objectName, object, instrumentation) {
        var methods = instrumentation.methods

        //var methodOptions = instrumentation.options
        //if (methodOptions.callback) {
            for (var j = 0; j < methods.length; j++) {
                var method = methods[j]

                var wrapFunction
                if (method === 'each') {
                    wrapFunction = wrapEach
                } else {
                    wrapFunction = moduleNameToWrapFunction[objectName]
                }

                if (wrapFunction) {
                    shimmer.wrapMethod(
                      object.prototype,
                      'mongodb.' + objectName + '.' + method,
                      method,
                      wrapFunction
                    )
                } else {
                    logger.trace('No wrapping method found for %s', objectName)
                }
            }
        //}
    }

    function instrumentModule(module) {
        var object = module.obj
        var instrumentations = module.instrumentations
        for (var i = 0; i < instrumentations.length; i++) {
            applyInstrumentation(module.name, object, instrumentations[i])
        }
    }

    // instrument using the apm api
    if (mongodb.instrument) {
      mongodb.instrument({}, instrumentModules)
     return
    }

    // fallback to legacy enumerations
    if (mongodb.Cursor && mongodb.Cursor.prototype) {
        // should wrapup stream aswell
        shimmer.wrapMethod(
          mongodb.Collection.prototype,
          'mongodb.Cursor.prototype',
          COLLECTION_OPS,
          wrapQuery
        )

        shimmer.wrapMethod(
          mongodb.Collection.prototype,
          'mongodb.Cursor.prototype',
          'each',
          wrapEach
        )
    }

    if (mongodb.Collection && mongodb.Collection.prototype) {
        shimmer.wrapMethod(
          mongodb.Collection.prototype,
          'mongodb.Cursor.prototype',
          COLLECTION_OPS,
          wrapQuery
        )
    }

    if (mongodb.Grid && mongodb.Grid.prototype) {
        shimmer.wrapMethod(
          mongodb.Grid.prototype,
          'mongodb.Grid.prototype',
          GRID_OPS,
          wrapGrid
        )
    }

    if (mongodb.Db && mongodb.Db.prototype) {
        for (var i = 0, l = DB_OPS.length; i < l; ++i) {
            shimmer.wrapMethod(
              mongodb.Db.prototype,
              'mongodb.Db.prototype',
              DB_OPS[i],
              wrapDb
            )
        }

        shimmer.wrapMethod(mongodb.Db, 'mongodb.Db', 'connect', wrapDb)
    }

    function wrapOp(original, name, wrapper) {
        return function wrapped() {
            var args = tracer.slice(arguments)
            var last = args.length - 1
            var callback = typeof args[last] === 'function' ? args[last] : null
            var transaction = tracer.getTransaction()
            var collection = this.collectionName || 'unknown'

            if (this.collection && this.collection.collectionName) {
                collection = this.collection.collectionName
            } else if (this.s && this.s.name) {
                collection = this.s.name || collection
            } else if (this.ns) {
                collection = this.ns.split(/\./)[1] || collection
            }

            if (!callback) {
                logger.trace(
                  'Not tracing MongoDB %s.%s(); no callback.',
                  collection,
                  name
                )

                return original.apply(this, args)
            } else if (!transaction) {
                logger.trace(
                  'Not tracing MongoDB %s.%s(); no Cloud Wise transaction.',
                  collection,
                  name
                )

                return original.apply(this, args)
            } else if (inMongoSegment(tracer)) {
                logger.trace(
                  'Not tracing MongoDB %s.%s(); Already in a mongo segment',
                   collection,
                   name
                )

                return original.apply(this, args)
            }

            return wrapper.call(this, args, last, collection)
        }
    }

    function wrapQuery(original, opName) {
        return wrapOp(original, opName, function wrappedQuery(args, last, collection) {
            var segment = addMongoStatement(tracer, collection, opName)
            var callback = args[last]

            logger.trace(
              'Tracing MongoDB %s.%s().',
              collection,
              opName
            )

            // capture configuration information if available
            if (this.db && this.db.serverConfig) {
                segment.host = this.db.serverConfig.host
                segment.port = this.db.serverConfig.port
            } else if (this.s && this.s.topology) {
                segment.host = this.s.topology.host
                segment.port = this.s.topology.port

            }

            switch (opName) {
                case "indexes":
                    segment.pst = 23030101;
                    break;
                case "indexExists":
                    segment.pst = 23030102;
                    break;
                case "indexInformation":
                    segment.pst = 23030103;
                    break;
                case "insert":
                    segment.pst = 23030104;
                    break;
                case "insertMany":
                    segment.pst = 23030105;
                    break;
                case "insertOne":
                    segment.pst = 23030106;
                    break;
                case "drop":
                    segment.pst = 23030201;
                    break;
                case "dropAllIndexes":
                    segment.pst = 23030202;
                    break;
                case "dropIndex":
                    segment.pst = 23030203;
                    break;
                case "remove":
                    segment.pst = 23030204;
                    break;
                case "deleteMany":
                    segment.pst = 23030205;
                    break;
                case "deleteOne":
                    segment.pst = 23030206;
                    break;
                case "update":
                    segment.pst = 23030301;
                    break;
                case "updateMany":
                    segment.pst = 23030302;
                    break;
                case "updateOne":
                    segment.pst = 23030303;
                    break;
                case "findOne":
                    segment.pst = 23030401;
                    break;
                case "findAndModify":
                    segment.pst = 23030402;
                    break;
                case "findAndRemove":
                    segment.pst = 23030403;
                    break;
                case "findOneAndDelete":
                    segment.pst = 23030404;
                    break;
                case "findOneAndReplace":
                    segment.pst = 23030405;
                    break;
                case "findOneAndUpdate":
                    segment.pst = 23030406;
                    break;
                case "findByIdAndRemove":
                    segment.pst = 23030407
                    break;
                case "find":
                    segment.pst = 23030408
                    break;
                case "findByIdAndUpdate":
                    segment.pst = 23030409
                    break;
                case "findById":
                    segment.pst = 23030410
                    break;
                case "bulkWrite":
                    segment.pst = 230305;
                    break;
                case "aggregate":
                    segment.pst = 230306;
                    break;
                case "count":
                    segment.pst = 230307;
                    break;
                case "createIndex":
                    segment.pst = 230308;
                    break;
                case "distinct":
                    segment.pst = 230309;
                    break;
                case "ensureIndex":
                    segment.pst = 2303010;
                    break;
                case "geoHaystackSearch":
                    segment.pst = 2303011;
                    break;
                case "geoNear":
                    segment.pst = 2303012;
                    break;
                case "group":
                    segment.pst = 2303013;
                    break;
                case "isCapped":
                    segment.pst = 2303014;
                    break;
                case "mapReduce":
                    segment.pst = 2303015;
                    break;
                case "options":
                    segment.pst = 2303015;
                    break;
                case "mapReduce":
                    segment.pst = 2303016;
                    break;
                case "parallelCollectionScan":
                    segment.pst = 2303017;
                    break;
                case "reIndex":
                    segment.pst = 2303018;
                    break;
                case "rename":
                    segment.pst = 2303019;
                    break;
                case "replaceOne":
                    segment.pst = 2303020;
                    break;
                case "save":
                    segment.pst = 2303021;
                    break;
                case "stats":
                    segment.pst = 2303022;
                    break;
            }

            segment.dbName = this.s.dbName
            segment.dbn_raw = this.s.dbName
            segment.nameSpace = this.s.namespace
            segment.args = args
            segment.userName = this.s.name
            segment.service_type = 205
            segment.resouce = { "tag": "2301", "host": segment.host, "dbName": segment.dbName, "port": segment.port, "userName": segment.userName };

            args[last] = tracer.wrapCallback(callback, segment, function wrappedCallback() {
                segment.touch()
                logger.trace('Tracing MongoDB %s.%s() ended.', collection, opName)
                //var iod = new IOData();
                //iod.send(segment);
                return callback.apply(this, arguments)
            })

            return tracer.bindFunction(original, segment).apply(this, args)
        })
    }

    function wrapEach(original, opName) {
        console.log(opName);
        return wrapOp(original, opName, function wrappedEach(args, last, collectionName) {
            var segment = addMongoStatement(tracer, collectionName, opName)
            var callbackBatch = null
            var callback = args[last]
            var collection = this

            logger.trace('Tracing MongoDB %s.%s().', collection, opName)

            // capture configuration information if available
            if (this.db && this.db.serverConfig) {
                segment.host = this.db.serverConfig.host
                segment.port = this.db.serverConfig.port
            } else if (this.s && this.s.topology) {
                segment.host = this.s.topology.host
                segment.port = this.s.topology.port


            }

            args[args.length - 1] = wrappedCallback
            if (opName == 'findOne') { segment.souceCode = 2302 }
            if (opName == 'open') { segment.souceCode = 2301 }
            segment.dbName = this.s.dbName
            segment.nameSpace = this.s.namespace
            segment.args = args
            return tracer.bindFunction(original, segment).apply(this, args)

            function wrappedCallback(err, item) {
                segment.touch()

                if (err || item === null) {
                    logger.trace('Tracing MongoDB %s.%s(%s) ended.', collection, opName)
                }

                if (!callbackBatch) {
                    callbackBatch = tracer.wrapCallback(
                      callback,
                      segment,
                      function wrapBatch() {
                          if (!collection.items || !collection.items.length) {
                              callbackBatch = null
                          }
                          return callback.apply(this, arguments)
                      }
                    )
                }

                return callbackBatch.apply(this, arguments)
            }
        })
    }

    function wrapGrid(original, opName) {
        return wrapOp(original, opName, function wrappedGridOp(args, last) {
            var name = MONGODB.OPERATION + 'GridFS-' + opName
            var callback = args[last]
            var grid = this

            // TODO: should look into adding a recorder for this
            return tracer.addSegment(name, null, null, false, segmentWrapper)

            function segmentWrapper(segment) {
                args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)

                return original.apply(grid, args)

                function nrCallbackWrap() {
                    segment.touch()
                    logger.trace('Tracing MongoDB Grid.%s() ended.', opName)
                    return callback.apply(this, arguments)
                }
            }
        })
    }

    function wrapDb(original, opName) {
        return wrapOp(original, opName, function wrappedGridOp(args, last) {
            var name = MONGODB.OPERATION + opName
            var callback = args[last]
            var db = this

            // TODO: should look into adding a recorder for this

            return tracer.addSegment(name, null, null, false, segmentWrapper)

            function segmentWrapper(segment) {
                args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)

                return tracer.bindFunction(original, segment).apply(db, args)

                function nrCallbackWrap() {
                    segment.touch()
                    logger.trace('Tracing MongoDB %s() ended.', opName)
                    return callback.apply(this, arguments)
                }
            }
        })
    }
}


var MONGO_RE = new RegExp(
  '^(?:' + MONGODB.STATEMENT + ')|(?:' + MONGODB.OPERATION + ')'
)
function inMongoSegment(tracer) {
    return MONGO_RE.test(tracer.getSegment().name)
}

function addMongoStatement(tracer, collection, opName) {
    var statement = new ParsedStatement(MONGODB.PREFIX, opName, collection)
    var recorder = statement.recordMetrics.bind(statement)
    var name = MONGODB.STATEMENT + collection + '/' + opName

    var segment = tracer.createSegment(name, recorder)
    segment.start()
    return segment
}







































//'use strict'

//var ParsedStatement = require('../db/parsed-statement')
//var shimmer = require('../shimmer')
//var logger = require('../logger').child({ component: 'mongodb' })
//var MONGODB = require('../metrics/names').MONGODB
////var IOData = require('../metrics/iodata')

//// legacy endpoint enumerations
//var DB_OPS = [
//  'addUser',
//  'authenticate',
//  'collection',
//  'collectionNames',
//  'collections',
//  'command',
//  'createCollection',
//  'createIndex',
//  'cursorInfo',
//  'dereference',
//  'dropCollection',
//  'dropDatabase',
//  'dropIndex',
//  'ensureIndex',
//  'eval',
//  'executeDbAdminCommand',
//  'indexInformation',
//  'logout',
//  'open',
//  'reIndex',
//  'removeUser',
//  'renameCollection',
//  'stats',
//  '_executeInsertCommand',
//  '_executeQueryCommand'
//]

//var COLLECTION_OPS = [
//  'aggregate',
//  'bulkWrite',
//  'count',
//  'createIndex',
//  'deleteMany',
//  'deleteOne',
//  'distinct',
//  'drop',
//  'dropAllIndexes',
//  'dropIndex',
//  'ensureIndex',
//  'findAndModify',
//  'findAndRemove',
//  'findOne',
//  'findOneAndDelete',
//  'findOneAndReplace',
//  'findOneAndUpdate',
//  'geoHaystackSearch',
//  'geoNear',
//  'group',
//  'indexes',
//  'indexExists',
//  'indexInformation',
//  'insert',
//  'insertMany',
//  'insertOne',
//  'isCapped',
//  'mapReduce',
//  'options',
//  'parallelCollectionScan',
//  'reIndex',
//  'remove',
//  'rename',
//  'replaceOne',
//  'save',
//  'stats',
//  'update',
//  'updateMany',
//  'updateOne',
//  'findByIdAndRemove',
//  'find',
//  'findByIdAndUpdate',
//  'findById'
//]

//var GRID_OPS = [
//  'put',
//  'get',
//  'delete'
//]

//var CURSOR_OPS = [
//  'nextObject',
//  'next',
//  'toArray',
//  'count',
//  'explain'
//]

//module.exports = initialize

//function initialize(agent, mongodb) {
//    if (!mongodb) return
//    var tracer = agent.tracer
//    var moduleNameToWrapFunction = {
//        'GridStore': wrapGrid,
//        'OrderedBulkOperation': wrapQuery,
//        'UnorderedBulkOperation': wrapQuery,
//        'CommandCursor': wrapQuery,
//        'AggregationCursor': wrapQuery,
//        'Cursor': wrapQuery,
//        'Collection': wrapQuery,
//        'Db': wrapDb
//    }

//    function instrumentModules(err, instrumentations) {
//        if (err) {
//            logger.trace('Unable to instrument mongo using the apm api due to error: %s', err)
//            // fallback to legacy instrumentation?
//            return
//        }
//        instrumentations.forEach(instrumentModule)
//    }

//    function applyInstrumentation(objectName, object, instrumentation) {
//        var methods = instrumentation.methods
//        var methodOptions = instrumentation.options
//        if (methodOptions.callback) {
//            for (var j = 0; j < methods.length; j++) {
//                var method = methods[j]

//                var wrapFunction
//                if (method === 'each') {
//                    wrapFunction = wrapEach
//                } else {
//                    wrapFunction = moduleNameToWrapFunction[objectName]
//                }

//                if (wrapFunction) {
//                    shimmer.wrapMethod(
//                      object.prototype,
//                      'mongodb.' + objectName + '.' + method,
//                      method,
//                      wrapFunction
//                    )
//                } else {
//                    logger.trace('No wrapping method found for %s', objectName)
//                }
//            }
//        }
//    }

//    function instrumentModule(module) {
//        var object = module.obj
//        var instrumentations = module.instrumentations
//        for (var i = 0; i < instrumentations.length; i++) {
//            applyInstrumentation(module.name, object, instrumentations[i])
//        }
//    }

//    // instrument using the apm api
//    if (mongodb.instrument) {
//        mongodb.instrument({}, instrumentModules)
//        return
//    }

//    // fallback to legacy enumerations
//    if (mongodb.Cursor && mongodb.Cursor.prototype) {
//        // should wrapup stream aswell
//        shimmer.wrapMethod(
//          mongodb.Cursor.prototype,
//          'mongodb.Cursor.prototype',
//          CURSOR_OPS,
//          wrapQuery
//        )

//        shimmer.wrapMethod(
//          mongodb.Cursor.prototype,
//          'mongodb.Cursor.prototype',
//          'each',
//          wrapEach
//        )
//    }

//    if (mongodb.Collection && mongodb.Collection.prototype) {
//        shimmer.wrapMethod(
//          mongodb.Collection.prototype,
//          'mongodb.Cursor.prototype',
//          COLLECTION_OPS,
//          wrapQuery
//        )
//    }

//    if (mongodb.Grid && mongodb.Grid.prototype) {
//        shimmer.wrapMethod(
//          mongodb.Grid.prototype,
//          'mongodb.Grid.prototype',
//          GRID_OPS,
//          wrapGrid
//        )
//    }

//    if (mongodb.Db && mongodb.Db.prototype) {
//        for (var i = 0, l = DB_OPS.length; i < l; ++i) {
//            shimmer.wrapMethod(
//              mongodb.Db.prototype,
//              'mongodb.Db.prototype',
//              DB_OPS[i],
//              wrapDb
//            )
//        }

//        shimmer.wrapMethod(mongodb.Db, 'mongodb.Db', 'connect', wrapDb)
//    }

//    function wrapOp(original, name, wrapper) {
//        return function wrapped() {
//            var args = tracer.slice(arguments)
//            var last = args.length - 1
//            var callback = typeof args[last] === 'function' ? args[last] : null
//            var transaction = tracer.getTransaction()
//            var collection = this.collectionName || 'unknown'

//            if (this.collection && this.collection.collectionName) {
//                collection = this.collection.collectionName
//            } else if (this.s && this.s.name) {
//                collection = this.s.name || collection
//            } else if (this.ns) {
//                collection = this.ns.split(/\./)[1] || collection
//            }

//            if (!callback) {
//                logger.trace(
//                  'Not tracing MongoDB %s.%s(); no callback.',
//                  collection,
//                  name
//                )

//                return original.apply(this, args)
//            } else if (!transaction) {
//                logger.trace(
//                  'Not tracing MongoDB %s.%s(); no Cloud Wise transaction.',
//                  collection,
//                  name
//                )

//                return original.apply(this, args)
//            } else if (inMongoSegment(tracer)) {
//                logger.trace(
//                  'Not tracing MongoDB %s.%s(); Already in a mongo segment',
//                   collection,
//                   name
//                )

//                return original.apply(this, args)
//            }

//            return wrapper.call(this, args, last, collection)
//        }
//    }

//    function wrapQuery(original, opName) {
//        return wrapOp(original, opName, function wrappedQuery(args, last, collection) {
//            var segment = addMongoStatement(tracer, collection, opName)
//            var callback = args[last]

//            logger.trace(
//              'Tracing MongoDB %s.%s().',
//              collection,
//              opName
//            )

//            // capture configuration information if available
//            if (this.db && this.db.serverConfig) {
//                segment.host = this.db.serverConfig.host
//                segment.port = this.db.serverConfig.port
//            } else if (this.s && this.s.topology) {
//                segment.host = this.s.topology.host
//                segment.port = this.s.topology.port

//            }

//            switch (opName) {
//                case "indexes":
//                    segment.pst = 23030101;
//                    break;
//                case "indexExists":
//                    segment.pst = 23030102;
//                    break;
//                case "indexInformation":
//                    segment.pst = 23030103;
//                    break;
//                case "insert":
//                    segment.pst = 23030104;
//                    break;
//                case "insertMany":
//                    segment.pst = 23030105;
//                    break;
//                case "insertOne":
//                    segment.pst = 23030106;
//                    break;
//                case "drop":
//                    segment.pst = 23030201;
//                    break;
//                case "dropAllIndexes":
//                    segment.pst = 23030202;
//                    break;
//                case "dropIndex":
//                    segment.pst = 23030203;
//                    break;
//                case "remove":
//                    segment.pst = 23030204;
//                    break;
//                case "deleteMany":
//                    segment.pst = 23030205;
//                    break;
//                case "deleteOne":
//                    segment.pst = 23030206;
//                    break;
//                case "update":
//                    segment.pst = 23030301;
//                    break;
//                case "updateMany":
//                    segment.pst = 23030302;
//                    break;
//                case "updateOne":
//                    segment.pst = 23030303;
//                    break;
//                case "findOne":
//                    segment.pst = 23030401;
//                    break;
//                case "findAndModify":
//                    segment.pst = 23030402;
//                    break;
//                case "findAndRemove":
//                    segment.pst = 23030403;
//                    break;
//                case "findOneAndDelete":
//                    segment.pst = 23030404;
//                    break;
//                case "findOneAndReplace":
//                    segment.pst = 23030405;
//                    break;
//                case "findOneAndUpdate":
//                    segment.pst = 23030406;
//                    break;
//                case "findByIdAndRemove":
//                    segment.pst = 23030407
//                    break;
//                case "find":
//                    segment.pst = 23030408
//                    break;
//                case "findByIdAndUpdate":
//                    segment.pst = 23030409
//                    break;
//                case "findById":
//                    segment.pst = 23030410
//                    break;
//                case "bulkWrite":
//                    segment.pst = 230305;
//                    break;
//                case "aggregate":
//                    segment.pst = 230306;
//                    break;
//                case "count":
//                    segment.pst = 230307;
//                    break;
//                case "createIndex":
//                    segment.pst = 230308;
//                    break;
//                case "distinct":
//                    segment.pst = 230309;
//                    break;
//                case "ensureIndex":
//                    segment.pst = 2303010;
//                    break;
//                case "geoHaystackSearch":
//                    segment.pst = 2303011;
//                    break;
//                case "geoNear":
//                    segment.pst = 2303012;
//                    break;
//                case "group":
//                    segment.pst = 2303013;
//                    break;
//                case "isCapped":
//                    segment.pst = 2303014;
//                    break;
//                case "mapReduce":
//                    segment.pst = 2303015;
//                    break;
//                case "options":
//                    segment.pst = 2303015;
//                    break;
//                case "mapReduce":
//                    segment.pst = 2303016;
//                    break;
//                case "parallelCollectionScan":
//                    segment.pst = 2303017;
//                    break;
//                case "reIndex":
//                    segment.pst = 2303018;
//                    break;
//                case "rename":
//                    segment.pst = 2303019;
//                    break;
//                case "replaceOne":
//                    segment.pst = 2303020;
//                    break;
//                case "save":
//                    segment.pst = 2303021;
//                    break;
//                case "stats":
//                    segment.pst = 2303022;
//                    break;
//            }

//            segment.dbName = this.s.dbName
//            segment.dbn_raw = this.s.dbName
//            segment.nameSpace = this.s.namespace
//            segment.args = args
//            segment.userName = this.s.name
//            segment.service_type = 205
//            segment.resouce = { "tag": "2301", "host": segment.host, "dbName": segment.dbName, "port": segment.port, "userName": segment.userName };

//            args[last] = tracer.wrapCallback(callback, segment, function wrappedCallback() {
//                segment.touch()
//                logger.trace('Tracing MongoDB %s.%s() ended.', collection, opName)
//                //var iod = new IOData();
//                //iod.send(segment);
//                return callback.apply(this, arguments)
//            })

//            return tracer.bindFunction(original, segment).apply(this, args)
//        })
//    }

//    function wrapEach(original, opName) {
//        console.log(opName);
//        return wrapOp(original, opName, function wrappedEach(args, last, collectionName) {
//            var segment = addMongoStatement(tracer, collectionName, opName)
//            var callbackBatch = null
//            var callback = args[last]
//            var collection = this

//            logger.trace('Tracing MongoDB %s.%s().', collection, opName)

//            // capture configuration information if available
//            if (this.db && this.db.serverConfig) {
//                segment.host = this.db.serverConfig.host
//                segment.port = this.db.serverConfig.port
//            } else if (this.s && this.s.topology) {
//                segment.host = this.s.topology.host
//                segment.port = this.s.topology.port


//            }

//            args[args.length - 1] = wrappedCallback
//            if (opName == 'findOne') { segment.souceCode = 2302 }
//            if (opName == 'open') { segment.souceCode = 2301 }
//            segment.dbName = this.s.dbName
//            segment.nameSpace = this.s.namespace
//            segment.args = args
//            return tracer.bindFunction(original, segment).apply(this, args)

//            function wrappedCallback(err, item) {
//                segment.touch()

//                if (err || item === null) {
//                    logger.trace('Tracing MongoDB %s.%s(%s) ended.', collection, opName)
//                }

//                if (!callbackBatch) {
//                    callbackBatch = tracer.wrapCallback(
//                      callback,
//                      segment,
//                      function wrapBatch() {
//                          if (!collection.items || !collection.items.length) {
//                              callbackBatch = null
//                          }
//                          return callback.apply(this, arguments)
//                      }
//                    )
//                }

//                return callbackBatch.apply(this, arguments)
//            }
//        })
//    }

//    function wrapGrid(original, opName) {
//        return wrapOp(original, opName, function wrappedGridOp(args, last) {
//            var name = MONGODB.OPERATION + 'GridFS-' + opName
//            var callback = args[last]
//            var grid = this

//            // TODO: should look into adding a recorder for this
//            return tracer.addSegment(name, null, null, false, segmentWrapper)

//            function segmentWrapper(segment) {
//                args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)

//                return original.apply(grid, args)

//                function nrCallbackWrap() {
//                    segment.touch()
//                    logger.trace('Tracing MongoDB Grid.%s() ended.', opName)
//                    return callback.apply(this, arguments)
//                }
//            }
//        })
//    }

//    function wrapDb(original, opName) {
//        return wrapOp(original, opName, function wrappedGridOp(args, last) {
//            var name = MONGODB.OPERATION + opName
//            var callback = args[last]
//            var db = this

//            // TODO: should look into adding a recorder for this

//            return tracer.addSegment(name, null, null, false, segmentWrapper)

//            function segmentWrapper(segment) {
//                args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)

//                return tracer.bindFunction(original, segment).apply(db, args)

//                function nrCallbackWrap() {
//                    segment.touch()
//                    logger.trace('Tracing MongoDB %s() ended.', opName)
//                    return callback.apply(this, arguments)
//                }
//            }
//        })
//    }
//}


//var MONGO_RE = new RegExp(
//  '^(?:' + MONGODB.STATEMENT + ')|(?:' + MONGODB.OPERATION + ')'
//)
//function inMongoSegment(tracer) {
//    return MONGO_RE.test(tracer.getSegment().name)
//}

//function addMongoStatement(tracer, collection, opName) {
//    var statement = new ParsedStatement(MONGODB.PREFIX, opName, collection)
//    var recorder = statement.recordMetrics.bind(statement)
//    var name = MONGODB.STATEMENT + collection + '/' + opName

//    var segment = tracer.createSegment(name, recorder)
//    segment.start()
//    return segment
//}
